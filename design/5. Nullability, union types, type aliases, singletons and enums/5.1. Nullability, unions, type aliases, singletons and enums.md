### Nullability, unions, type aliases, "singletons" and "enums"

Nothing is nullable unless specified:

```
max = (a: Array<Integer>) -> Integer | None { ... }
```

By the way, equivalent:

```
type Maybe some T = T | None
```

Or maybe (if for some reason we can't use `type`):

```
alias Maybe some T = T | None
```

And then:

```
max = (a: Array<Integer>) -> Maybe<Integer> { ... }
```

`some` is an experimental keyword for generics, not even needed for the above case, only for functions...\
But we will probably just require it in types too, for consistency, and that's it.

Also, sometimes, when we don't really care what `T` actually is in, let's say `Maybe<T>`, only that it's a `Maybe`,
then we simply say `Maybe<some>`.

**2023-04-27**: `some` is probably deprecated, not sure about `Maybe<T>` vs `Maybe[T]`, but that's just cosmetics...

So, `Optional<?>` in Java, pretty much.

#### "Singletons" and "enums"

The word "singleton" has too much association with design patterns in Java for me, so maybe not `singleton`.\
Probably not `object` either, because we're trying to be more FP and all that...\
Then maybe `unit` or `symbol`, or something. Anyway, just a value (so maybe `value`) sitting there, doing nothing,
and its purpose is to just exist and be returned from a function sometimes.

So a `unit` is its own type. Or a `unit` is a type with only one instance, named the same. Two ways of looking at it.

**2023-04-27**: `unit` instead of `value`, 99%, check 2.3. for explanation.

In such a way, an "enum" would be just a union of a few "singletons":

```
unit Up
unit Down
unit Left
unit Right

type Direction = Up | Down | Left | Right
```

In Kotlin, it would look like this:
```
sealed class Direction {
    object Up
    object Down
    object Left
    object Right
}
```

An example:

```
unit DivisionByZero

safeDivide = (dividend: Number, divisor: Number) -> Number | DivisionByZero {
    if divisor == 0 {
        return DivisionByZero
    }
    return dividend / divisor
}

result = safeDivide(3, 0)

if result is Number {
    ; result would be auto-cast to Number, but we never get here,
    ; because result is actually the DivisionByZero value, "singleton", symbol, whatever...
}
```