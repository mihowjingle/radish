So how about `this` keyword also being an option for the name of (only) the **first** argument of a function?
And then we can get rid of the `infix` keyword...

```
anyMatch = (this: Iterable[some E], predicate: E -> Boolean) -> Boolean {
    for element in this {
        if predicate(element) {
            return True
        }
    }
    return False
}
```

instead of

```
anyMatch = infix (elements: Iterable[some E], predicate: E -> Boolean) -> Boolean {
    for element in elements {
        if predicate(element) {
            return True
        }
    }
    return False
}
```

The only problem I can see is the overloading of `this`. It's already the keyword for an object to refer to itself,
and also probably will denote the "private" insides of a `slot`. But I wouldn't worry about it... for now.

**2025-11-24**

Ok, so apparently some people code in notepad, and they have problems distinguishing functions which are parts
of the originally designed interface, by, let's say the author of a library, and ad-hoc extensions...\
Jokes aside, even if you do code in notepad, you still have an import to follow, so I'm not convinced
about the lack of discoverability. Also, in an IDE, the autocomplete is great... You write the name of a constant,
and get suggestions after pressing the dot key. With "normal" `function(x)` syntax, you have to know the functions name.\
So it's **better** discoverability, not worse. And it _reads like natural English_,
which is a big part of my design philosophy for Radish.

`isGreaterThan(x, y)` or `x.isGreaterThan(y)` - the choice is obvious.

And for the implementation... It's just syntactic sugar.

But I guess I could consider using another operator instead of `.`,
maybe `|` if it gets freed up after I make up my mind about union types (remember multiline `String`s too), or `..`, for extra clarification...
Or making the "extension" functions only `infix` as in `x isGreaterThan y`, or something... But probably not.

**TODO**

Also, maybe introduce `::` as "extension operator", at least for defining and _maybe_ for using:

```
Array[any A]::find = (predicate: A -> Boolean) -> [A, None] {
    for element in this {
        if predicate(element) {
            return element
        }
    }
    return None
}

isOdd: Integer -> Boolean = (x) { x % 2 == 1 }

one = [1, 2, 3].find(isOdd)
```

Then making "extension properties" would be possible:

```
Array[any A]::last: A = this[this.length - 1]

three = [1, 2, 3].last
```

Or _maybe_:

```
one = [1, 2, 3]::find(idOdd)
three = [1, 2, 3]::last
```

But probably not, since this could lead the impression that it's more than just syntactic sugar.\
And also muddles the function type. And extension properties hide the fact that they are actually functions.