### Data types

How about some, say, `data type`s, which cannot have function types in them and now, since they're immutable
and can't "accept", or "consume" anything anyhow (no functions), then they're automatically covariant?
Other, regular types would be invariant, that's it, no discussion? So a "flexibility vs simplicity" trade off?

Probably not that last part. Automatically covariant `data type`s shouldn't restrict the freedom for regular `type`s to have variance
(definition- **and** use-site, by the way), it would be just a bonus.
Although it's kind of implicit ("explicit > implicit" in general), which could confuse beginners... as if variance itself was something trivial...

Anyway, maybe `data type`s could have other convenient "auto"-features, like `toString`, equality and all that, or...

### Serialization

`data type`s could somehow have "auto-magic" serialization? (No reflection, so no Jackson/Gson for Radish)\
But how, code generated by the compiler? That would require the compiler to know json, xml, and all the formats in the world?!\
`data type`s would have to provide some kind of metadata... which then we would consume when writing a serializing function for a given format...

Maybe if they provided ~~an `Array<String>`, or anyway,~~ a sequence, ~~with property names and a way to get the values by the names...\
But get the values as what? No root type, like `Object` in Java...
But if `data type`s also automatically have some equivalent of `toString`, as did all the "primitives"~~ ... Nope, what's the format??

... a sequence of some `type SerializationNode = Branch | Leaf`, which means... (theoretically) cycles, so... uh... weak references? **TODO**

... or a sequence of `Map<String, String | Map<String, UMMM...>>`... OMG, so... time to invent "recursive types" _(1)_?

... or a sequence of `Map<String, String | _>` and then we would have a "gentleman's agreement" that the value is either a `String`,
or a `Map<String, _>` whose values are then either `String`, or... and so on... and we can safely cast, even though it's technically
not protected by the type system. Is this even possible?\
But wait, wouldn't it be a `Map<String, String | Serializable>`?
Something, which you could even provide manually, by implementing a...

```
type Serializable {
    someMetadataOrSomething: Map<String, String | Serializable>
}
```

So again, ok, cycles, ok, weak references, but anyway, you can provide an implementation for any type, and `data type`s
would just have it automatically?

_(1)_ Waaaait! `... another keyword like "self" or "this", but to refer to the type in question??` in 14.7., sounds familiar...

A `Map<String, String | recursiveOrReflexiveTypeKeywordHere>`?! Is **this** even possible? Not to send the compiler itself into stack overflow?

----

Anyway, would be nice not to have to write _x * y_ very similar functions when you want to serialize _x_ types into _y_ formats...\
Oh, and another _x * y_ functions to parse...\
Those poor web app developers :D