### How do we tell the compiler "this is a generic type"?

I wanted something maybe a little simpler for Radish and I came up with `some T` as in `type MyType some T` and `func = (value: some T) -> T {}`.\
(We only need to mark the generic type once, the first time we encounter it. That way, we don't have to do some `<T>` before,
or something, like `func = <T> (value: T) -> T {}`). Is that bad, though?

Also, I'm not sure if we have it out-of-the-box, but if not, I want to make sure generics are reified.

Problems (kind of, maybe):
1. In types, it's actually redundant to say `some`, we already know it's generic from the `<...>` after the name of the type.
2. Check 14.3. Empty array. I mean, there is nowhere to put the `some T` if a function receives no parameters
   (not really FP style in the first place, but...)

**By the way: covariance, contravariance?**

No inheritance, no problem... right?

Anyway, the origin of this idea was to have a (generic) function type `some T -> some R`, rather than... I don't know, `<T, R> T -> R`, or something...\
The latter looks messy. And also, with `some`, we have a way of saying we don't care about the type for free: `MyType<some>`, for Java's `MyType<?>`.

A new idea:\
`<T> -> <R>`, or `[T] -> [R]` and `MyType[T]` (the latter obviously clashing with arrays). Eh, I don't know...\
But (I'm pretty sure) Scala (and Python?) does it with `[]`... **TODO**

**2023-04-16**:

How about defining generic types with:

```
type Couple some A, B {
    first: A
    second: B
}

type Maybe some T = T | None
```

Then, `some` would be the keyword for **defining** generic types **and** functions,
and `<...>` would be the operator for **using** them.\
Plus the special case of `Maybe<some>` for Java's `Optional<?>`, because it's kind of both at the same time:\
defining and using, but we don't really care, wildcard, whatever...

If not, then maybe `Maybe<_>` since `_` will probably be the "I don't care operator" anyway... But probably `Maybe<some>`...