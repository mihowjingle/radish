### Multi-assign? Maybe...

TBD, but basically Python (except there are no tuples involved, pure syntactic sugar).

```
x, y = 1, 2
```

### String interpolation
```
x = 5
write("Five equals {x}.")
text = "Seven equals {x + 2}."
write(text)
```

Obviously we have to escape `{` with a `\{`.

### Operator overloading?
```
TODO, 50/50
```

### Destructuring? Useful enough?

49% yes, 51% no on this...

```
type Point {
    x: Integer
    y: Integer
}

p = Point {
    x = 1
    y = 7
}

a, b = p

; a == 1, b == 7
```

And how about...

```
type Person {
    firstName: String
    lastName: String
    age: Integer
}

person = Person {
    firstName = "Anna"
    lastName = "Smith"
    age = 33
}

name, _, age = person
```

`_` for when we don't care?

### Smart casts

Like Kotlin or TypeScript:

```
type TypeA {
    a: Integer
}

type TypeB {
    b: String
}

someFunction = () -> TypeA | TypeB {
    ...
}

result = someFunction()
write(result.a) ; compilation error
if result is TypeA {
    write(result.a) ; ok
}
```

By the way, "normal" casts with `as`, sure, why not, then you take responsibility:

```
result = someFunction() as TypeA
write(result.a) ; no compilation error, but may crash
```

### Local functions - yes. Types - maybe? Probably... Why not?

```
function = () {
    localFunction = () {}    
    plus: Integer, Integer -> Integer = (x, y) { x + y }
    
    ...
}
```

### Dangling commas, etc.

```
quiteOk = [
    1,
    4,
    5,
]
```

99% yes.