### Operators

"Semantic", as in full words:

- `&&` -> `and`,
- `||` -> `or`,
- `xor`,
- `!` -> `not`, *especially* this one, I'm allergic to `!`, easy to miss, or confuse with `i`, `I`, `l`, `|`, even `;` etc...
- `for (x : list) {}` -> `for x in list {}`
- ... and so on

But not always: still `5 + 6`, not `5 plus 6`, so yeah, need to find balance.

All other operators:
- Comparisons: `> >= <= < == =/=`, last one being "not-equal", since I'm already not using exclamation mark for logical negation\
  Bonus: easy enough to type, no need for shift key
- By the way, in Kotlin `===` is identity, and _if_, _IF_ for some reason I do identity in Radish: `@=` (99.9% not)
- `+ - / * **` arithmetics, probably even `//` like in Python, since we already have `**`, just have to use something else for comments,\
  and since we have `**` then, maybe something for root? (probably not, feature creep, also root of degree x is just power to 1/x)
- Something for Kotlin's `?:`? ~~Overloaded `else`? Overloaded `or`? Probably `otherwise`, probably~~ as a function ~~though...~~
- `is` (instance of type)
- `%` modulo... **actually, just check 13.1. for all operators**
- Bitwise operators? Kind of low-level, probably not...

Kotlin:

```
val notNullString = nullableString ?: "default"
```

Radish (probably... not?):

```
notNullString = nullableString otherwise "default"
```

Actually, with union types (`SomeType | None` instead of `SomeType?`, like in Kotlin),
is it possible to make it an operator without too much duct tape? Or even advantageous?\
What's wrong with a `notNullString = nullableString.otherwise("default")`