#### Keywords:

- `type` - definition of a custom type, not an object though, so not `class`, more like `interface`, if anything
- `is` ...instance of type
- `if`
- `else`
- `return`
- `with` ...accumulator, for use in loops
- `but` - to help cope with the lack of mutability, like "this value, _but_ with some properties changed"
- `while`
- `break`
- `continue`
- `for`
- `in`
- `from` - when we want to import only some stuff, but not the entire file... basically Python
- `import`
- `as` - casting types
- `error` - to define an error ("exception")
- `try`
- `panic` - `throw` in other languages
- `rescue` - `catch` in other languages
- `finally` - `finally` in other languages
- `value` - for a kind of "singleton", a type with exactly one instance
- `self` - kind of like `this` for objects in other languages, but for functions, for recursion (all functions are anonymous)
- `slot` - simple local object template, pretty much `class`, different from `type` in that these objects are mutable (and so have identity)
- `constructors` - inside of `slot`s, for (named) constructors
- `properties` - inside of `slot`s, for "getters"
- `mutations` - inside of `slot`s, for "setters"

#### Maybe keywords:

- `alias` if for some reason I can't "overload" `type` for stuff like `type Maybe<T> = T | None`
- `elif` if `else if` is... somehow... not an option? I don't know, 99% no on this
- `when` / `match` - switch-like multi-if, for pattern matching etc., actually this shouldn't be in the "maybe" section,\
  one of these (or something similar) is definitely going to be in Radish, I just can't decide which
- `inline` for, well, inlining functions and maybe some other stuff, an inline function's code gets copied into where it's invoked,\
  the function "disappears" in compilation
- `internal`, or maybe `private` to prevent stuff from being imported in other files, unless I pull a 180 on this\
  and everything is private unless `export`ed, but 99% not
- `otherwise` - I'm 99% sure it will be a function in the stdlib, but anyway, `?:` in Kotlin
- `infix`, or maybe `extension`, for functions whose first argument will be "on the left", before the dot, just some syntactic sugar
- `some`, for generics, like let's say `map = (array: Array<some T>, function: T -> some R) -> Array<R> { ... }`\
  instead of `map = <T, R> (array: Array<T>, function: T -> R) -> Array<R> { ... }`, we will see, 50/50 on this
- `recur`, or something, if I decide that it sounds better than `self`, for recursion (unlikely)

#### Operators:
- `and or not xor` logical
- `+ - * /` standard arithmetic
- `**` power
- `//` floor/whole division
- `%` modulo
- `> >= <= < == =/=` comparisons
- `@=` identity, if I do identity (so almost certainly no)
- `=` assignment
- `|` as in `Type | OtherType` union types
- `()` function invocation
- `[]` access to an element of an array, array literal
- `<T>` for type `T`, generic types
- `{}` not really an operator, but inside of strings, indicates interpolation
- operator overloading?

#### Other:
- `root`, an `Array<String> -> None` or a `None -> None`, the main function
- `Error`, the "standard", "generic" error, for when there's nothing to say besides "whoops!"
- `arg`, the implicit argument of a single-argument function, Kotlin (and Groovy/Scala, I think): `it`