I had this brief glimpse of only allowing `panic` with a String, as in:

```
factorial = (x: Integer) -> Integer {
    if x < 0 {
        panic "negative factorial argument!"
    }
    if x == 0 {
        return 1
    }
    return x * self(x - 1)
}
```

But what about rescuing errors? Panicking with a String would actually be nice, if we never ever intended to `rescue`.
But if I do this, we can't rescue an error and return a union type, for example... In other words, if we disagree with
an APIs author that something is a problem, without `rescue` we can't use their code. We have to write our own.
And rescuing strings is just... meh... So is rescuing everything, because of x possible errors, which one just occurred?

**2025-11-23**

Looks like I have to remove `rescue`. Panic is panic. Syntax is `panic "error message"` and that's it.
Want "checked exceptions"? Use union types. And I guess maybe some force-casting operator for when you know something
is impossible, and you are willing to take responsibility.

Except... what about server or GUI applications?
Should an error in one request handler of a REST API crash the entire server? Eh...

**TODO**

Anyway, the goal is to make it impossible to bypass normal flow control, by "throwing" results around.

**2025-11-25**

Or maybe... Only throwing `value`s? And empty types so that they can be inherited from by the values...

```
type Error ; stdlib

type ArgumentError of Error ; stdlib

value NegativeFactorialArgument of ArgumentError

factorial = (x: Integer) -> Integer {
    if x < 0 {
        panic NegativeFactorialArgument
    }
    if x == 0 {
        return 1
    }
    return x * self(x - 1)
}
```

Although... maybe we can create a separate hierarchy. And `error` keyword to declare errors

```
error Error ; stdlib

error ArgumentError of Error ; stdlib

error NegativeFactorialArgument of ArgumentError

factorial = (x: Integer) -> Integer {
    if x < 0 {
        panic NegativeFactorialArgument
    }
    if x == 0 {
        return 1
    }
    return x * self(x - 1)
}
```

And then you only ever `panic SomeError` and `return SomeValue` or `return someValueOfSomeType()`, but never vice versa...?