- An **enum** - a type with all possible values known, all of which conform to the interface of the enum exactly.
- A **sealed** type - a type with all possible values or types of values known, of which some may exceed the interface of the sealed type.
- A **union** type - a type constructed from existing types with no requirements in terms of the interface of its values or types of values.
Can be defined ad-hoc.

**TODO**: right?

**Question: how, if possible, to make one concept, a hybrid that a programmer can mold to fit either of the above**

Ok, first idea: Provided `[]` doesn't clash with array literals and parameterized (generic) types, then...

A. An "enum"
```
value North
value East
value South
value West

type Direction [North, East, South, West]

; or

type Direction [
    North,
    East,
    South,
    West
]

; or even, if the values were not declared before

type Direction [
    value North,
    value East,
    value South,
    value West
]

; and if we want to add common interface for all Directions

type Direction {
    label: String
} [
    value North of Direction {
        label = "north"
    },
    value East of Direction {
        label = "east"
    },
    value South of Direction {
        label = "south"
    },
    value West of Direction {
        label = "west"
    }
]

; and if the values already existed and we did this:

type Direction {
    label: String
} [
    North,
    East,
    South,
    West
]

; ... we would get a compilation error because the values don't conform to type Direction
```
... _but_ if they _did_... yeah, no problem, which means we could use existing - even imported from libraries or whatever - 
types to "plug them in" to our sealed types/enums, edit: nvm, they can't, only now `type Direction` is being defined,
and "building" the interface of `Direction` here, as the common part of interfaces of the values smells of duck typing...

B. A "sealed type"

```
value Problem

type Result any R [R, Problem]

; or, of course...

type Result any R [R, value Problem]

type Result any R [
    R,
    Problem
]

; and so on

wholeDivide: Integer, Integer -> Result[Integer] = (x, y) {
    if y == 0 {
        return Problem
    }
    return x // y
}

r = wholeDivide(5, 0)

if r is Integer {
    ; r is smart-cast to Integer
} else {
    ; r is smart-cast to Problem, we can see that this is the branch we will end up in
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;

type Someone [
    type Person {
        name: String
    },
    value Anonymous
]

greet = (someone: Someone) {
    if someone is Anonymous {
        write("Hello, stranger!")
    } else {
        write("Hello, {someone.name}!")
    }
}
```

C. And finally, a "union type"

```
[String, Integer] ; ad-hoc

type StringOrInteger [String, Integer]

; or if type Someone from above didn't exist

greet = (someone: [Person, Anonymous]) {
    if someone is Anonymous {
        write("Hello, stranger!")
    } else {
        write("Hello, {someone.name}!")
    }
}

find = (this: Array[any A], predicate: A -> Boolean) -> [A, None] {
    for element in this {
        if predicate(element) {
            return element
        }
    }
    return None
}

isOdd: Integer -> Boolean = (x) { x % 2 == 1 }

[1, 2, 3].find(isOdd)

; 1
```

So I probably also need a new name, because between, enums, sealed types, and union, these would be all of them... 
and none of them, exactly. So, like... "finite types", "multiple types", "multi-types" or whatever...

Aaaand... **There is a problem**: `type Type any A { ...` Ok, cool, then we use it as `Type[A]`.\
But then, it extends some other type: `type Subtype any A of Supertype[A] { ...`.\
So what does the `of` pertain to? `type Subtype (any A) of Supertype[A]` or `type Subtype any (A of Supertype[A])`?
Well, neither, there isn't even a way to express it, but we want `Subtype` to be `of Supertype`.
So probably we are going with `type Subtype[A] of Supertype[A]`.

Which means that there is but a whitespace of difference between ahead-of-time defined, named union `type Direction [Left, Right]`
and generic `type Direction[A, B]`. That, and the fact that the convention for type parameters is to be single letters... but it's possible, so...

Solution (because I like `[]` for union types) - generics will use `<>` as in `type Box<A>`, just like Java, Kotlin, and most languages.

However, I also like `[]` for generics, so as soon as the final design for enum/sealed/union types settles, and it doesn't collide,
it's back to `[]` for generics.

Hmm, I would kind of like to keep both. So maybe `type Direction is [Left, Right]` instead of `type Direction [Left, Right]`?
Or some other keyword, or maybe even `=` instead of `is`... Probably not, but **TBD**, keep thinking.

---

So, new approach: with exhaustive type checks, we can resign from "rich enums",
and enums can just be sets of possible values and that's that:

```
value North
value East
value South
value West

type Direction union [North, East, South, West]

; or...

type Direction union {
type Direction choice {
union type Direction {
choice type Direction {
finite type Direction {
    value North,
    value East,
    value South,
    value West
}
```

If we wanted `Direction` to have, let's say the `label: String` property, like above, we just make a function:

```
label: Direction -> String = (direction) {
    return when direction {
        is North    then "north"
        is East     then "east"
        is South    then "south"
        is West     then "west"
    }
}
```

And the compiler ensures both that no brach is missing, nor is there `else` branch, because all the possibilities
are already checked. At the same time, adding new values to `Direction` makes `label` not compile anymore,
so it's not possible to forget to add a branch.\
And there we have it.

---

Or... The only difference between a regular and a finite/choice/case/enum/union type would be a special clause inside:

```
type Person {
    name: String
    age: Integer
}
```
```
type Person {
    name: String
    age: Integer
    
    options {
        value Mike {
            name = "Mike"
            age = 22
        },
        value Steve {
            name = "Steve"
            age = 33
        }
    }
}
```

But... how do we add existing types? What if there is no common interface?

```
type Direction {
    options {
        value North,
        value East,
        value South,
        value West
    }
}
```
Looks... so-so...

```
type Maybe[A] {
    options {
        value None,
        A
    }
}
```
Looks quite verbose and ugly. Nope...

So maybe...

```
value South ; because why not, this one already exists

type Direction {
    case value North
    case value East
    case South ; notice no "value", it is already declared
    case value West
}
```

Again... Something's off...

So for now, the design is (`None` already exists in stdlib):

```
type Maybe[A] union [A, None]

type Result[A] union [
    A,
    value Problem
]

[String, Integer] ; ad-hoc, like below:

fiftyFifty: any A -> [A, None] = (x) { if randomBoolean() x else None }

type Creature union [
    type Person {
        name: String
        age: Integer
    },
    type Pet {
        name: String
        species: type Species union [
            value Cat,
            value Dog
        ]
    }
]
```

Now...
1. I'm tempted to disallow ad-hoc anonymous unions `[any A, None]`, always have named ones: `Maybe[A]`
2. How do we impose common interface on the options of such a union? Like this?
```
type Creature {
    name: String
} union [
    type Person {
        name: String
        age: Integer
    },
    type Pet {
        name: String
        species: type Species union [
            value Cat,
            value Dog
        ]
    }
]
```
Or with functions?
```
type Creature union [
    type Person {
        name: String
        age: Integer
    },
    type Pet {
        name: String
        species: type Species union [
            value Cat,
            value Dog
        ]
    }
]

name: Creature -> String = (creature) {
    return when creature {
        is Person   then creature.name
        is Pet      then creature.name
    }
}
```
Yeah, looks stupid...

What about reversing the structure:
```
union Maybe[A] { None, A }

union Outcome {
    value Success
    value Failure
}

union Creature {
    type {
        name: String
    }
    
    type Person {
        name: String
        age: Integer
    },
    type Pet {
        name: String
        species: type Species union [
            value Cat,
            value Dog
        ]
    }
]
```
Yeah... The apparently "nameless type" is the type of the whole union, then we have the options - type this, type that...
Hmm... Not great either...

Also, what about adding existing types to such a union then? Like this?
```
type Dragon {
    name: String
}

type Creature {
    name: String
} union [
    type Person {
        name: String
        age: Integer
    },
    type Pet {
        name: String
        species: type Species union [
            value Cat,
            value Dog
        ]
    },
    include Dragon ; experimental keyword to "import" or "pull in" existing types/values
]
```

Wait... Aren't ad-hoc nameless unions just a compile-time guarantee? Does such a type exist in runtime? I think not...?

In such case, then I think we have to forbid them...
Also, doesn't it require for there to be a root type, like `Object` in Java? Maybe not...

---

Oh, crap!

```
[1, 2, 3].map((x) { if x.odd then x else None }) ; [1, None, 3]
```

The type of the above expression is `List[[Integer, None]]`. Looks... Eh... `List[Integer | None]` looks better.

And also, yeah, such syntax for union types clashes with `[]` array literal.
At least when it comes to an array of some singleton values vs a union type of such values:

```
value Blue
value Reg
value Green
value Yellow
value Black
value Purple

[Blue, Red, Yellow]
```
What is that in the square brackets? Array literal or anonymous/ad-hoc union type?