Damn!

Damn-damn!

Great Scott!

This was right under my nose for so long... Anyway, I forbid mutable objects from being captured in closures after predicting
problems with concurrency. But also, check 14. Samples - memoized. That's pretty harmless and useful...

What do we do? Looks like sometimes it would be good to forbid it, other times, we really shouldn't.

**Solution?**\
Not sure yet, but somehow detect when it is and isn't a problem? Like, forbid it by default, unless...
The **only** thing we're doing with such an object is capturing it in a closure?
Not sure how, not sure if it won't be too confusing, not sure if there are _still_ cases where it would be too restrictive...
_Not sure..._

**BIG TODO**, but see 13.30. Looks promising...

**2025-11-24**

Wait... I think I know...

```
memoized: (any A of Equatable[A] -> any B) -> (A -> B) = (function) {
```
```
memoized: [A of Equatable[A], B] (A -> B) -> (A -> B) = (function) {
```
```
memoized = [A of Equatable[A], B] (function: A -> B) -> (A -> B) {
```
```
memoized = (function: any A of Equatable[A] -> any B) -> (A -> B) {
    cache = MutableMap[A, B].new()
    return (input: A) -> B {
        maybeResult = cache.get(input)
        if maybeResult =/= None {
            return maybeResult
        } else {
            result = inline function(input)
            cache.put(input, result)
            return result
        }
    }
}
```

There is no problem, because the map gets created here, locally, and passed around together,
as a kind of 2-in-1 deal with any function that gets memoized, but it is never accessed directly.

No multiple references where we mutate the object by one, and we get surprised when the state of the object pointed to
by the other reference also changes, etc.

---

Unless... That makes the following legal too:

```
slot Counter { ... } ; starts at 0, goes up by one, returns current state

makeNext = () {
    counter = Counter.new()
    return () {
        counter.increment()
        return counter.currentValue()
    }
}

next = makeNext()

write(next())
write(next())
write(next())
```

Result:

```
1
2
3
```

So they are all like "a function with memory". But is that a problem? **TODO**

I mean the _potential_ problem is that we cannot pass instances of `slot` around, but we can pass `next`...

So...? What about more complex examples where it _is_ a problem? Are there any?

---

Hmmm...

```
value Get
value Post
value Put
value Delete
; ...

type Method = [Get, Post, Put, Delete]

type Request {
    ; various stuff, "context" etc., whatever the framework injects into handlers
}

type Response[R] {
    body: R
    status: HttpStatus
    ; ... etc.
}

type HttpServer {
    listen: Method, String, (Request -> Response[any R]) -> None
    ; more functions corresponding to more methods in ActualHttpServer
}

; btw, this type is just "bunch together" all the functions representing ActualHttpServer's methods in one "namespace"
; and to make sure they all talk to the same object

slot ActualHttpServer {

    this {
        listeners = List[Listener].new()
    }
    
    mutations {
        addListener = (method: Method, url: String, handler: Request -> Response[any R]) {
            listeners.append(Listener.new(method, url, handler))
        }
        
        ; more methods
    }
}

createHttpServer = () {
    actualServer = ActualHttpServer.new()
    return HttpServer {
        listen = (method: Method, url: String, handler: Request -> Response[any R]) {
            actualServer.addListener(method, url, handler)
        }
        
        ; ...
    }
}

root = {
    http = createHttpServer()
    http.listen(Get, "/:id", (request) {
        id = request.parameter("id")
        return "Requested item {id}"
    })
    http.start()
}
```

Now... Did I just add boilerplate around returning `slot` objects from functions? Even though we can't do it directly?