### There are no exceptions...

... only errors, and whether something is recoverable or not,
can be known at the call site, the client programmer knows, not the library author.

But it's discouraged anyway. Errors should be available (only) as a "plug"
to appease the language when you know something is impossible, but the compiler doesn't.

And maybe when it's hard to say, but you just can't be bothered
(in which case you take responsibility if it does crash after all).\
At least then it's a clear and simple fail-fast situation.

To emphasize this, `throw` from other languages is `panic` and `catch` is `rescue`.

**Errors are for situations which are not supposed to occur!**

So what to replace Java's second-biggest mistake with? Values and union types.

```
value NegativeFactorialArgument

safeFactorial = (x: Integer) -> Integer | NegativeFactorialArgument {
    if x < 0 {
        return NegativeFactorialArgument
    }
    if x == 0 {
        return 1
    }
    return x * self(x - 1)
}
```
```
error NegativeFactorialArgument

unsafeFactorial = (x: Integer) -> Integer {
    if x < 0 {
        panic NegativeFactorialArgument
    }
    if x == 0 {
        return 1
    }
    return x * self(x - 1)
}
```

Which to use? I don't know, you should know - it's your code in which you're about to use it.\
Did you validate the input already?

You can always use `unsafeFactorial` and then `rescue NegativeFactorialArgument`, if you insist - again, your choice.

```
value MyCustomValue ; could just use None, I guess

safeDivide = (x: Number, y: Number) -> Number | MyCustomValue {
    try {
        return x / y
    } rescue e: DivisionByZero {
        return MyCustomValue
    }
}

; ... or just check if y == 0 before, with an if, but I just wanted to show a "try-rescue"

root = () {
    x = readNumber()
    y = readNumber()
    result: Number = safeDivide(x, y) ; compilation error, check the type
}
```

Maybe (probably) referencing the error could be optional if we're not using any information in it,
when the type itself is enough.

```
nullableDivide = (x: Integer, y: Integer) -> Number | None {
    try {
        return x / y
    } rescue DivisionByZero {
        return None
    }
}
```

All errors have an implicit property `message: String | None` for logging, debugging and such,
and maybe a `cause: some T | None`, where `T` has to be an error.\
There is a built-in, general-purpose `error Error`.\
`panic "Oh no!"` is syntactic sugar for `panic Error("Oh no!")`.\
`panic` (without anything else) is syntactic sugar for `panic Error`, which is the most "lazy" or "generic" option.

```
if someCondition {
    ; this will never happen, I don't care, yolo
    panic
}
```

Remember, however, that the rule about being specific when throwing errors you've learned in other languages applies in Radish too.\
It's so that the users of your code, other programmers, can ~~catch~~, _cough_ `rescue` a specific error, not "all or nothing".\
On the other hand, don't just `rescue` (even though I guess I will leave it possible), instead, always `rescue SomeError`.\
Even `rescue ErrorA, ErrorB` (`rescue ErrorA | ErrorB`?) if they both can be handled in the same way (in the same block).

You could argue, that if I'm so against (checked) exceptions, maybe `/` operator itself should return a `Number | DivisionByZero`
in which case the `DivisionByZero` would be a `value` not an `error`?
I guess not - we'll just say that `/` **expects** the divider to be non-zero.

Just like **you're not supposed to** try to get a 5th element of a 4-element array, and so on...\
(I will probably make a `safeGet` or `nullableGet` function or something, in the stdlib, though):

```
safeGet = infix (array: Array<some T>, index: Integer) -> T | None {
    return try {
        array[index]
    } rescue IndexOutOfBounds {
        None
    }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

willBeNone = [1, 2, 3].safeGet(3)
```

But that's a digression.

And finally (pun possibly unintended), `finally`. It's just `finally`, like in every other language.

Should `try` be an expression, like in Kotlin? Probably... Maybe... TBD.