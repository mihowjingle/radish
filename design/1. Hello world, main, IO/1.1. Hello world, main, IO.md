# Radish

Crisp, healthy, and my favourite :)

### Why though...

Another programming language? Don't we have enough of those?\
Well... At first, I wanted to learn, or at least try to learn LLVM and how to design a language.
Also, at roughly the same time I came up with the idea of "compile-time garbage collection".\
Best of both worlds: efficient, but you don't have to worry about it.
What if the compiler always knew exactly where to generate code to deallocate memory?
We already have local variables on the stack in most (all?) languages, so maybe,
with enough concessions when it comes to the features of the language, other clever techniques could be possible,
if even needed.\
Turns out I'm not a genius and people have thought about it, but anyway...

It's just a fun experiment and if in 20 years it becomes the most popular programming language, then good,
but if I get bored with it in a month and leave it, then also good.

After some thinking and reading, and thinking more - while the original goals still stand,
now I would say the language is evolving into (an impure) "functional language which looks like
your average mainstream, hybrid, general-purpose language".

With all this in mind, I hope to achieve the following:
- A simple language, with a smooth learning curve (maybe long, but smooth, flat). Statically typed. Compiled.
- Minimal, optional (I think), and discouraged mutability, mostly just constants (values), which are created and destroyed.
- "First class citizen" functions, which are inherently anonymous (can be assigned, passed around) and all that FP goodness.
- Automatic, simple, efficient memory management.

### "main" and I/O (filthy side effects)

```
root = () {
    write("What is your name?")
    name = read()
    write("Hello, {name}!")
}
```

`root` is a special name which can be assigned one of the following: a `None -> None` (like above) or a `Array<String> -> None`, which are function types.