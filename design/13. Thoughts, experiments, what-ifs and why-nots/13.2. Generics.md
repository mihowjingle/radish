### How do we tell the compiler "this is a generic type"?

I wanted something maybe a little simpler for Radish and I came up with `some T` as in `type MyType some T` and `func = (value: some T) -> T {}`.\
(We only need to mark the type parameter once, the first time we encounter it. That way, we don't have to do some `<T>` before,
or something, like `func = <T> (value: T) -> T {}`). Is that bad, though?

Also, I'm not sure if we have it out-of-the-box, but if not, I want to make sure generics are reified.

Problems (kind of, maybe):
1. In types, it's actually redundant to say `some`, we already know it's generic from the `<...>` after the name of the type.
2. Check 13.3. Empty array. I mean, there is nowhere to put the `some T` if a function receives no parameters
   (not really FP style in the first place, but...)

**By the way: covariance, contravariance?**

No inheritance, no problem... right?

Anyway, the origin of this idea was to have a (generic) function type `some T -> some R`, rather than... I don't know, `<T, R> T -> R`, or something...\
The latter looks messy. And also, with `some`, we have a way of saying we don't care about the type for free: `MyType<some>`, for Java's `MyType<?>`.

A new idea:\
`<T> -> <R>`, or `[T] -> [R]` and `MyType[T]` (the latter obviously clashing with arrays). Eh, I don't know...\
But (I'm pretty sure) Scala (and Python?) does it with `[]`... **TODO**

**2023-04-16**:

How about defining generic types with:

```
type Couple some A, B {
    first: A
    second: B
}

type Maybe some T = T | None

type Either some A, B = A | B ; hehehe
```

Then, `some` would be the keyword for **defining** generic types **and** functions,
and `<...>` would be the operator for **using** them.\
Plus the special case of `Maybe<some>` for Java's `Optional<?>`, because it's kind of both at the same time:\
defining and using, but we don't really care, wildcard, whatever...

If not, then maybe `Maybe<_>` since `_` will probably be the "I don't care operator" anyway... But probably `Maybe<some>`...

-----

**2023-04-17: OK, let's try to sum it all up...**

**Option A:** some

```
type Couple some A, B {
    first: A
    second: B
}

type Maybe some T = T | None

iDontCare: Maybe<some> = ...

returnCount: List<some> -> Integer = (list: List<some>) -> Integer {
   return list.count
}

function: some T -> some R = ...

map1: (Array<some I>, I -> some O) -> Array<O> = ...

map2 = (list: List<some T>, function: T -> some R) -> List<R> { ... }

filter = (list: List<some T>, predicate: T -> Boolean) -> List<T> { ... }
```

**Good:**
- generic function types look great: `some A -> some B`, `find: (Set<some E>, E -> Boolean) -> Maybe<E>`
- shines when we're defining some and using more, already defined, generics; thanks to the "remembering" from left to right
- not caring about the type in a generic type looks great: `Maybe<some>` for Java's `Optional<?>`
- conforms with my approach about preferring keywords and full-word operators like `not` instead of `!`, which is easy to miss,
  `and` instead of `&&`, etc.

**Bad:**
- slightly longer, scales poorly with more complex definitions
- unorthodox, may seem weird to some experienced programmers (I wonder about beginners though, maybe, after learning this first,
  they'd say that the "standard", option B, is weird?)
- it feels like there are still 2 systems, `<...>` is still used, `some` is only for defining (and as the wildcard)

**Option B:** standard from other languages

```
type Couple<A, B> {
    first: A
    second: B
}

type Maybe<T> = T | None

iDontCare: Maybe<_> = ...

returnCount: List<_> -> Integer = (list: List<_>) -> Integer {
   return list.count
}

function: <T, R> T -> R = ...

map1: <I, O> (Array<I>, I -> O) -> Array<O> = ...

map2 = <T, R> (list: List<T>, function: T -> R) -> List<R> { ... }

filter = <T> (list: List<T>, predicate: T -> Boolean) -> List<T> { ... }
```

**Good:**
- most familiar for most programmers
- sometimes it actually does look better (complex definitions of types)
- feels more "unified", `<...>` when defining **and** when using...

**Bad:**
- generic function types look... what the hell is this?: `<A, B> A -> B`, slightly better: `find: <E> (Set<E>, E -> Boolean) -> Maybe<E>`
- thankfully, we already have `_` for not caring about other things, like unused parameters, why not use it in `Maybe<_>`, but still, meh...
  (maybe use some other operator, like `?`, `*`, or something, or even `some`, but an entire keyword just for this??)
- opposes my approach about preferring keywords and full-word operators like `not` instead of `!`, which is easy to miss,
  `and` instead of `&&`, etc., (especially the wildcard)

**Option C:** also standard, but less often (Python, Scala, ...?)

```
type Couple[A, B] {
    first: A
    second: B
}

type Maybe[T] = T | None

iDontCare: Maybe[_] = ...

returnCount: List[_] -> Integer = (list: List[_]) -> Integer {
   return list.count
}

function: [T, R] T -> R = ...

map1: [I, O] (Array[I], I -> O) -> Array[O] = ...

map2 = [T, R] (list: List[T], function: T -> R) -> List[R] { ... }

filter = [T] (list: List[T], predicate: T -> Boolean) -> List[T] { ... }
```

**Good:**
- pretty much as in option B, but `[` and `]` don't require pressing Shift, while `<` and `>` do
- `[A, B] A -> B` looks marginally better than `<A, B> A -> B`
- `<` and `>` are already used often, maybe more than `[` and `]` (especially `>` in `->`)

**Bad:**
- pretty much as in option B, but may clash with arrays?
  (maybe not, `<` and `>` are already "less than" and "greater than" and it's not a problem)

**Verdict:** I don't know, but probably between options A and C...

------

Actually, what good is a `some T -> some R`, a `<T, R> T -> R`, or a `[T, R] T -> R` by itself?\
We don't know anything about `T` or `R`, we need context, and in a context, there will be type inference etc., so...
Yeah, this will probably not be such a problem, after all...

**2023-04-19:**

"Also, (...) I want to make sure generics are reified."

(https://openjdk.org/projects/valhalla/design-notes/in-defense-of-erasure "heterogeneous translation" then?)

Aaaaahhh... Nice! So, `erased` keyword? :) To give control the programmer? Or `reified`,
depending on which is the better, more often needed, default.

```
type Box[T] {
    if T is String {
        ; cool?
    }
}

type Box[erased T] {
    if T is String {
        ; not cool?
    }
}
```

Probably `reified`, actually - when you need it and don't put it there, the compiler will complain,
otherwise, the compiler knows it can optimize.
With `erased`, you may have a lot of reified types for nothing, and the compiler knows it can optimize only when
you don't forget to put `erased`.

Or... something? **TODO**

Also 1: https://stackoverflow.com/questions/31876372/what-is-reification

Also 2: wouldn't it be `reified type Box[T] { ... }` instead of `type Box[reified T] { ... }`? Or are both valid?
In which case each choice would have some advantages and flaws, as always...

With `reified` inside `[]` maybe can we have "selectively reified parameterized/generic types"?

```
type PartiallyReified[A, reified B] {
    ...
}
```

Looks like out of Java, C# and C++, the C++ way speaks to me the most, if I understand it correctly **TODO** keep learning...

Another idea: What if the compiler could know when to make a type parameter reified, and when it's not necessary?\
For example, based on the lack/presence of `if myConstant is T { ... }`?
So it would automatically make it reified in this case, but generally, not?

Also 3: from what I understand, for some reason, "not caring about the type parameter" as in Java's `Optional<?>`, Kotlin's `List<*>`,
Radish's `Set<some>` / `Set[_]` (TBD), and so on, is impossible with reification?\
And reification kills variance? Why?

And apparently, LLVM doesn't have reified generics... UGHH... (https://news.ycombinator.com/item?id=19983599)

**2025-11-05**

Actually, maybe, if we use `some`, we can just use it at the site of the first encounter with the generic type, as in:

```
type Couple {
    first: some A
    second: some B
}
```

But is it better? Or easier to implement in the compiler? Also, there is still the need for `<>` or `[]`, for, let's say `List[String]`

**2025-11-22**

Ok, there is 1 little problem. Compare the lengths:

```
functionWithManyParameters = [A, B, C, D, E, F, G, H] (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) { ... }
functionWithManyParameters: [A, B, C, D, E, F, G, H] (A, B, C, D, E, F, G, H) -> None = (a, b, c, d, e, f, g, h) { ... }
```
```
functionWithManyParameters = (a: some A, b: some B, c: some C, d: some D, e: some E, f: some F, g: some G, h: some H) { ... }
functionWithManyParameters: (some A, some B, some C, some D, some E, some F, some G, some H) -> None = (a, b, c, d, e, f, g, h) { ... }
```

Hmmm.... So, actually it's not that bad (it's not a problem with the above (2025-11-05), but with generic functions, anyway).

By the way... This makes `any` more attractive as a generic keyword than `some` - one letter shorter I guess...
```
functionWithManyParameters = (a: any A, b: any B, c: any C, d: any D, e: any E, f: any F, g: any G, h: any H) { ... }
functionWithManyParameters: (any A, any B, any C, any D, any E, any F, any G, any H) -> None = (a, b, c, d, e, f, g, h) { ... }
```

... and then `some` can be the name of the function that takes a predicate and checks if any (some) elements match in an iterable.

By the way 2:

```
functionWithManyParameters = (a: let A, b: let B, c: let C, d: let D, e: let E, f: let F, g: let G, h: let H) { ... }
functionWithManyParameters: (let A, let B, let C, let D, let E, let F, let G, let H) -> None = (a, b, c, d, e, f, g, h) { ... }
```

... `let`? ~~Maybe... Probably not, unless I can't decide between `some` and `any`.~~

```
map = (this: Iterable[let A], function: A -> let B) -> List[B] {
    accumulator = List[B].new()
    for element in this {
        accumulator.append(function(element))
    }
    return accumulator
}

justThree = Array.new(1, 2, 3).map({ arg > 2 })
```

Aaahhh... Ok, never mind - `List[some]` looks good, so does `List[any]`, but `List[let]`? Nah...

What about something crazy, like...

```
functionWithManyParameters: ([A], [B], [C], [D], [E], [F], [G], [H]) -> None = (a, b, c, d, e, f, g, h) { ... }
```

Is that even possible? Are there drawbacks? **TODO**

Let's sum up the options so far:

```
functionWithManyParameters: (some A, some B, some C, some D, some E, some F, some G, some H) -> None = (a, b, c, d, e, f, g, h) { ... }
functionWithManyParameters: (any A, any B, any C, any D, any E, any F, any G, any H) -> None = (a, b, c, d, e, f, g, h) { ... }
functionWithManyParameters: ([A], [B], [C], [D], [E], [F], [G], [H]) -> None = (a, b, c, d, e, f, g, h) { ... }
```

**2025-11-23**

Example from 2023-04-16 for reference:
```
type Couple some A, B {
    first: A
    second: B
}

type Maybe some T = T | None

type Either some A, B = A | B
```
Alternative syntax (hmmm... I don't know...):
```
Couple = type {
    first: any A
    second: any B
}

Maybe = type any T | None

Either = type any A | any B
```
Or at least `any` replaces `some`:
```
type Couple any A, B {
    first: A
    second: B
}

type Maybe any T = T | None

type Either any A, B = A | B
```
Analogically, the "crazy" option (which in the context of types doesn't look that crazy, especially for someone used to Java, etc.):
```
type Couple[A, B] {
    first: A
    second: B
}

type Maybe[T] = T | None

type Either[A, B] = A | B
```
... aaaand never mind the "crazy option":
```
only = (this: List[A], predicate: A -> Boolean) -> List[A] {
    accumulator = List[A].new()
    for element in this {
        if predicate(element) {
            accumulator.append(element)
        }
    }
    return accumulator
}
```
How do we indicate that `A` is a type parameter?

---

```
Named = type {
    name: String
}

names = (this: Iterable[any N of Named]) {
    accumulator = List[String].new()
    for named in this {
        accumulator.append(named.name)
    }
    return accumulator
}
```

... ok, never mind, we could have just used `Named` by itself... but sometimes we need the `N`... **TODO** come up with example

But anyway, that would be the syntax.