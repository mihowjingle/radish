Once I had completed the design snapshot of 2023-04-28, I had 2 major problems remaining:
- How to provide automatic serialization of `data type`s to JSON and other formats, without the programmer having to write
tedious, repetitive functions `toJson`, `fromJson`, for every `data type`. I came up with some auto-generated `getProperties`
function, which would return a `Map[String, Writeable | Map[String, any]]`, and so on, recursively, and then, that
would be what library authors could "plug into". You know, some format-agnostic structure, basically... But that looks
kind of bad, if it's even technically correct.
- How to make the `memoized` function from 14. Samples? I forbid mutable objects from getting captured in closures!
To do it like that will be impossible...

So - code generation, I'm not sure yet if it's going to be a new keyword, let's say...

```
decorator json {
    ... some magic here
}
```

... or just a "special symbol", like...

```
@json = () {
    ... some magic here
}
```

Anyway, it would have to be something "on the border" between functions and metaprogramming, some "compile-time reflection", code generation, etc.
It would have to access the properties of the decorated `data type` (or just `type` at this point?) and "build"
the code of the function `toJson` and the... "constructor literal"? Or some `fromJson` function?
But where would that function be? Anyway:

```
@json type Person {
    name: String
    age: Integer
}

person = Person { name = "Ben", age = 33 } ; <- constructor literal, or something, I don't know, anyway, this thing
```

So maybe we need `namespace`s? Then, `fromJson` would simply go into the `namespace` of the type?

```
@json
type Point {
    x: Number
    y: Number
    
    namespace {
        origin = Point { x = 0.0, y = 0.0 } <- MANUALLY WRITTEN, basically public static final Point ORIGIN = ... in Java
        fromJson = (string: String) -> Point { ... } <- GENERATED by the compiler because of @json
    }
    
    toJson = (pretty: Boolean = False) -> String { ... } <- GENERATED by the compiler because of @json
    (pretty would be with all the whitespace and formatting, or we could reverse it: compact: Boolean = True)
}
```

Otherwise, we would have to describe the rule to name `fromJson` like `jsonToPoint`, `jsonToThis`, `jsonToThat` in the decorator...

**BIG TODO**, but it seems promising...

Now, `memoized`:

```
@memoized = [I of Equatable[I], O] (function: I -> O) -> (I -> O) {
    cache: MutableMap[I, O] = MutableMap.new()
    return (input: I) -> O {
        maybeResult = cache.get(input)
        if maybeResult =/= None {
            return maybeResult
        } else {
            result = inline function(input)
            cache.put(input, result)
            return result
        }
    }
}
```

Basically this, conceptually speaking at least (compare this with the `memoized` from the snapshot).

Now there is no "capturing a mutable object in a closure", it's just code generation.
I don't even know if we need the `inline`, but like I said, something more or less like this.

Then, the `function` itself (its code) would be "enriched", injected, or decorated with the `cache`:

```
myExpensiveFunction = @memoized (input: Integer) -> Integer { ... }
```

Maybe there could be `@reified` and `@transactional` etc... Instead of a keyword and a function, respectively...

`transactional` could be done both ways, I guess...

Anyway, wherever you see the symbol `@`, you know, there's some code generation behind the scenes in the process of compilation...

**TODO TODO TODO**

-----

Maybe there could be `@data type`s instead of `data type`s too? Pretty much Lombok...

Anyway, coming back to `@json`, to refer the thing that is being decorated, for functions, it's easy,
simply use the standard `Type -> Type` convention. What about types? `type @json`?
_That_ means it's not an actual type, but a decorator, the `@`?

```
quoted = (string: String) -> String {
    return "\"" ++ string ++ "\""
}

type @json {

    toJson = () -> String {
        buffer = StringBuffer.new("\{")
        for property in @json {
            jsonValue = when property {
                is String then quoted(property.value)
                is Decimal then property.value.toString()
                is Boolean then when property.value {
                    is True then "true"
                    is False then "false"
                }
                ; ... and so on
                else {
                    property.toJson()
                }
            }
            buffer.append(quoted(property.name))
            buffer.append(":")
            buffer.append(jsonValue)
            buffer.append(",") ; except the last property but you get the gist
        }
        buffer.append("}")
        return buffer.toString()
    }
    
    namespace {
        fromJson = (json: String) -> @json {
            ; I can't be bothered, parse, parse... boom, object!
        }
    }
}
```

Yes, this probably isn't even correct, but anyway... something like this...

So the `@json` is like a placeholder for "this type", the type being decorated... I don't know, **TODO**...

We need a way to say that _this is how to generate_ and _that is what to generate_, I mean `for property in @json`...
there's not supposed to be any loops in the actual code. No runtime reflection!