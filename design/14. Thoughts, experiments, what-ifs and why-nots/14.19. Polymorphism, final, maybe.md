Since the best I could get in 14.18. was - pretty much what I wanted but also - having to duplicate `type`s and identical `feature`s
(probably quite often), then 14.14. stays.

But:

**Option A:**

As described in 14.14.: `feature`s are allowed only in function signatures, on the "in" side, as a (kind of) type, or a type projection.
So, only one of...
- `function = (type: Feature) -> Type { ... }`, which is short for...
- `function = (type: _ promises Feature) -> Type { ... }`, or
- `function = (genericType: Type[Feature]) -> Type { ... }`, which is short for...
- `function = (genericType: Type[_ promises Feature]) -> Type { ... }`, or
- `function = (genericType: Feature[Type]) -> Type { ... }`, which is short for...
- `function = (genericType: _ promises Feature[Type]) -> Type { ... }` (but this is just the first/second option), or
- `function = [T promises Feature] (type: T) -> Type { ... }`, or
- `function = [T promises Feature] (type: Type[T]) -> Type { ... }`

... and maybe `::`, or something, instead of `promises`...

**Option B:**

As described in 14.14.: `feature`s are allowed anywhere, but only as `_ promises Feature`, not directly.
Still not sure if that fixes contravariance though. And even if it does, then the `_ promises Something` will be
a frequent "pattern" of boilerplate.

**Option C:**

`type`s can not have functions, so actually `data type`s are just `type`s now. That would mean there is no way
that a `type` "consumes" something. Automatically covariant, boom! Then we can ditch `feature`s and let `type`s simply "extend"
each other. ~~Probably more like `type TypeC combines TypeA, TypeB` or just `type TypeC :: TypeA, TypeB`.
Because it's not exactly inheritance, even if "topologically" it is.~~ Wait, `type Dog combines Animal`? Combines with what?
Maybe `includes`, I don't know why not just `extends`, but well... Just some ideas...

For now, it's **A**, until something proves it to be a bad idea.

----

And if option **C** wins, let's copy (the main part of) 13.3. here, with changes applied:

```
basically a Java interface with only "getters", freely ("ad-hoc") instantiable, the most basic kind
 |          types, but allow functions; cannot be extended by "normal" types! as a type parameter, they make the "outter", generic type invariant!
 |           |              types, but "flattened" and continuous, basically Project Valhalla, I think - should be more performant, in general
 |           |               |
 v           v               v
type        function type   value type      <- immutable!


slot                                        <- "simple local object template",
                                               a (function, or regular) type, but mutable and can not be passed to a function,
                                               only local, or returned from a function,
                                               which is why it may end up being called "mutable type", not "slot"
                                               can be upcast to a (function, or regular) type (under certain conditions (see 8.4.))


value                                       <- a "singleton", or "unit", immutable, of course!
                                               ("unit" may end up being the keyword, actually)
```

Main difference:
- no `feature`s...
- ...but `function type`s, because sometimes it's still useful to have a function associated per-instance of some type, not per-type...
- `type`s as per 13.3. are now `function type`s
- `data type`s as per 13.3. are now `type`s

That would mean:
- a `type` can extend only other `type`s
- a `function type` can extend `type`s, `function type`s
- a `value type` can extend `value type`s and maybe `type`s, if it's not too confusing (should technically be possible, I think)
- a `slot` can extend `type`s, `function type`s, and we need `property` keyword to make `person.isAdult()` into `person.isAdult`, or...
- a `slot` can extend only `function type`s